完全递增子序列就是在一个数组中，只能通过删除或者选择 来找出一个完全升序的一个序列，他的对应索引也是完全升序，不能改变数组本来的顺序
比如我们有 1，3，6，5，8，2  那么1，3，5，8就是一个完全递增数列
那么我们通过怎样的找呢
第一张dp
第二种二分
我们首先需要另有一个数列或者list来装填我们的选出来的递增数列
比如1，3，6，5，8，2
我们首先先把1装进去，我们每次都在尾巴处装填以保证找一个递增的数列，那么装填3，紧接着就是，6，然后就来到了5，我们通过比较发现5是小于6 的所以就不能装填到最后一位
好，问题就来了，我们如何知道5该装到哪儿呢，遍历，是个好方法，不过太慢了，我们整个复杂度就会上去的，最好的方法是二分

我们只要找到最后一个比5小的数，那么他的下一位一定是第一个比5大的数，为什么的，因为我们装的时候就在刻意制造一个递增，我们的装填是通过比较最后一位的大小，来判断是否装填到尾巴上


这里最后一个比5小的就是3，所以我们下一位自然而然地就是第一个比5大的也就是6，把5替换了6，于是现在变成1，3，5
具体实现过程呢就是二分，我们先比较5和数列里中间位置元素地大小，如果5是大的，那么我们就要往右块找一找，如果5是小的我们要去左块找，整体是个while,不断分割数列，直到数列无法被分割
那么我们再分割的时候，加入5是大的那一方，也即是中间小于5，看到小于了，我们可以猜想这个小的数有可能就是最后一个比5小的，当然有可能不是，但是我们可以这样猜，我们先把一个temp记录下这个中间量
，加入我们进入右块进行下一次分割时发现，已经没法再分割了，那么说明这个temp一定就是最后一个比5小的，如果还能分割也没有关系，我们本身就是猜的嘛，temp会在下一次进入右块时被更新
也就是右块部分的中间量会变成temp,成为我们猜测的对象
拿如果并没有向我们想的那样怎么办，她进入右块分割后发现，这次要比中间值小，我们只能进左边了，那左边可没有记录的变量啊，没关系，假如她中间进入入左区间也是没关系的
只要进入右区间我们就一定拿到猜测的值，那如果一直都在左区间直到循环结束，那说明要跟没有比这个数更小的数了，这说明了什么，说明我们的这个数列第一项就不是最小的，我们要将其替换

比如这个题我们给的1，3，6，5，这是一个好例子，因为第一个就是最小的，我们就不会遇到这种情况，假如时，5，4，2，1这种，我们就需要不断更新头了

代码

class solution{
public int lengthOfLIS(int [] nums)
{    
    if(nums.length==0)
    {
    return 0;
    }
    int []arr=new int[nums.length+1];
    int len=1;
    arr[len]=nums[0];
    
    for(int i=1;i<nums.length;i++)
    {
      if（arr[len]<nums[i]）
      {
         arr[++len]=nums[i];
      }else{
           int l=0;  
           int r=len; 
           int temp=0;
           while(l<=r)
           {
              int mid=(l+r)/2;
              if(nums[i]>arr[mid])
              {
                l=mid+1;
                temp=mid;
              }else{
              r=mid-1;
              }
              
           }
           //直到循环结束都没找到一个属于他该放的位置，那说明他就是最小的，整个数列的任何数都比她大
           arr[temp+1]=nums[i];
      
      
      
      return len;
      }
    }
    
    
    
    
    
    
    
    
    
    
    
  }
   }
