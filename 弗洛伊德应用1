链接：https://ac.nowcoder.com/acm/problem/21884
来源：牛客网

题目描述 
一位客人来到了此花亭，给了女服务员柚一个数学问题：我们有两个函数，F(X)函数可以让X变成（X*X*X+X*X）mod 233。G(X)函数可以让X变成（X*X*X-X*X）mod 233，我们可以任意的对A使用F(X),和G(X)，问最少需要多少次使用这两个函数让A变成B。
输入描述:
第一行输入一个T，表示T组案例（T<100000），然后输入两个整数A,B，表示我们需要把A变成B。（0<=A<=2000000000，0<=B<=2000000000）
输出描述:
输出一个整数表示从A到B最少需要多少次操作，如果不能请输出-1.
示例1
输入
复制
1
2 186
输出
复制
2
说明
我们首先使用F(X)，将2变成(2*2*2+2*2)mod 233=12。然后我们再将12通过G(X)，变成(12*12*12-12*12)mod 233=186

我们首先分析一件事请就是amod b,假如a<b得到答案一定是a,且不论a的值是什么，得到的答案一定不会超过b，这是为什么呢，你见过余数比除数大的嘛
所以我们就可以进行特解，当输入的A B相同，那么答案一定是1，所以不需要变换就直接相同了
假若输入的B大于233，那么一定不存在，结果一定是负一
那剩下就剩两种情况，就是a大于233，a小于233
如果大于233，就进行f或者g变换，然后去弗洛伊德矩阵里找值，如果小于233，就直接去里面找
那么这个弗洛伊德矩阵里面装了什么呢，就是a小于233，b小于233，对应情况，通过两个函数把a取值看是否等于b，如果不等说明不存在，如果相等就说明存在

public class solution {
//time就是测试次数，我们测了多少次，输了多少次a,b
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int time = sc.nextInt();
        sc.nextLine();
        int dp[][] = new int[233][233];
        int arr[] = new int[time];
       int f1=0;
       int f2=0;
       int g1=0;
       int g2=0;
        for (int k = 1; k <= 233; k++) {
            for (int i = 1; i <= 233; i++) {
                if (k == 1) {                    //k=1，就是初始化，从1-233遍历，看它每个经过函数变化后侧结果
                    f1=F(i);
                    g1=G(i);
                }
                for (int j = 1; j <= 233; j++) {
                    if (k != 1) {
                        dp[i][j]=dp[i][k]+dp[k][j];   //这个就是普通弗洛伊德
                    } else {
                                if (j==i)dp[i][j]=0;   //矩阵里面i,i本来就是0
                               else if (j==g1||j==f1) dp[i][j]=1;//这里意思是经过函数变换的值是否与与b对应，因为b也是1-233，这里j模拟的就是b ，如果相同就给矩阵存1，代表相同
                               else dp[i][j]=99999 ;//这里意思就是除此自外都是inf，就是i,没办法到j
                               dp[i][j]=dp[i][k]+dp[k][j];  //这里别忘了，虽然第一遍是初始化，但是也要把这个加上
                    }
                }
            }
        }
        for (int i = 0; i < time; i++) {
            int a=sc.nextInt();
            int b=sc.nextInt();
            f2=F(a);//这里是为什么呢，仔细看下方函数，多了一个%233，这是为什么呢，其实在弗洛伊德里i,j都是小于233，所以相当于在弗洛伊德里这句话就是废话
            //但是在这里这句话就有作用了，他提供了一个筛选输入的a是不是小于233的方法，为什么呢，如果a<233，相当于没执行，如果大于233，则执行，相当于把a给缩小
            //因为我们开头说了，余数不可能比除数大的，所以一定是小于除数的
            g2=G(b);
             if(a==b) {arr[i]=0;continue;}     //这里就是相同不用变换
            if(b>=233) {arr[i]=-1;continue;}   //这是不可能的情况
            if (dp[f2][b]!=99999||dp[g2][b]!=99999)  //这里是我们已经缩小的情况或者a本来就小于233,我们相当于去弗洛伊德表里去找是不是有对应的b
            {
                arr[i]=Math.min(dp[f2][b],dp[g2][b])+1;// 这里有两点。重中之重就+1；为什么呢，因为我们在开头进行了一次看似无效的函数转换操作
                //假如转换了的话，我们要在总次数上+1，假如没转化，是不是就多加了1 呢，不是。
                //因为如果没转换，意思就是a本来就小于233，这样我们去表里找，因为这是已经转换过了的，所以如果这时转换过了的就直接对应的话，在弗洛伊德里对应的就是0
                //所以加上最开始的一次，就只有1次
            }else{
                arr[i]=-1;//上述都不行，就直接-1
            }

        }

    }

    static int F(int x) {
        x = x % 233;
        return ((x * x * x) + (x * x)) % 233;
    }

    static int G(int x) {
        x = x % 233;
        int ans = ((x * x * x) - (x * x)) % 233;
        return ans;
    }
}
