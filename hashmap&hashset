区别与联系
hashset是实现了set接口，它储存的为一个对象，不允许有重复且无序。通过add来增添，根据存储对象的哈希函数的值存放，对于两个对象来说hashcode可能相同，

所以equals()方法用来判断对象的相等性

如果两个对象不同的话，那么返回false  HashSet较HashMap来说比较慢
hashmap 实现了一个map接口，他储存的为一个键值对，采用键值映射，他同样也是无序且key是不允许重复的，采用put来添加，通过使用key来计算hashcode，那么对于
存储地址相同的情况会出现这个地址已经被别的数所占用的情况，于是产生了哈希冲突，而解决这个现象采用链地址法，即对于一个存储地址而言他就像一个长链，存储着地址相同的元素们
所以这个方法也可以说是2数组+链表的方式，但是同时产生了一个问题就是线程不安全。由于HashMap底层是一个Entry数组，当发生hash冲突的时候，hashmap是采用链表的方式来解决的，在对应的数组位置存放链表的头结点。

对链表而言，新加入的节点会从头结点加入。如果多个线程同时访问一个哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须 保持外部同步。

这一般通过对自然封装该映射的对象进行同步操作来完成。如果使用Collections.synchronizedMap 方法来“包装”该映射。最好在创建时完成这一操作，以防止对映射进行意外的非同步访问。    所以因为线程不安全所以速度快

hashmap的负载因子0.75原因
由于阙值=负载因子×容量，而一般容量是永远为2的幂次方，所以为了保证结果是整数使用0.75比较合理，注：所谓阙值和StringBuilder之类相同，容量为18，超过阙值12就会发生扩容
所以理论上，负载因子越大，那么哈希冲突的概率也就越大，负载因子越小，空间就会大，产生不必要的浪费，权衡利弊0.75最佳

那么关于扩容的事情，为什么扩容采用的位移运算，而不直接×2？

因为cpu不支持乘法运算，乘法运算在计算机原理中其实是以加法来产生的，而使用加法运算的效率很低，那么位移运算就显得更加方便

为什么hashmap的初始值为16呢
 hashmap每次扩容都是2的整数幂次方来进行的，16-1等于1111，末尾是1就能保证了进来的数可以是奇数也可以是偶数，只要传进来的key足够分散，获得index减少了重复的可能以及提高了效率
那么4，8不也行吗
4，8很容易就导致map扩容了，加入分配过大，就会导致浪费


关于表示若桶中链表元素超过8时，会自动转化成红黑树；若桶中元素小于等于6时，树结构还原成链表形式。 原因

红黑树的平均查找长度是log(n)，长度为8，查找长度为log(8)=3，链表的平均查找长度为n/2，当长度为8时，平均查找长度为8/2=4，4大于3，从8开始查找成本就变高了，这才有转换成树的必要；链表长度如果是小于等于6，6/2=3，虽然速度也很快的，
但是转化为树结构和生成树的时间并不会太短。

还有选择6和8的原因是：

　中间有个差值7可以防止链表和树之间频繁的转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，
如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。

class MyHashSet {

    int[] numArr;
    /** Initialize your data structure here. */
    public MyHashSet() {
        numArr = new int[31251];
    }

    public void add(int key) {
        setKey(key, true);
    }

    public void remove(int key) {
        setKey(key, false);
    }

    /** Returns true if this set contains the specified element */
    public boolean contains(int key) {
        return getKey(key);
    }

    private void setKey(int key, boolean add) {
        int idx = key >> 5;
        int bitIdx = key % 32;
        if(add) {
            numArr[idx] |= 1 << bitIdx;
        } else {
            numArr[idx] &= (~(1 << bitIdx));
        }
    }

    private boolean getKey(int key) {
        int idx = key >> 5;
        int bitIdx = key % 32;
        return (numArr[idx] >> bitIdx & 1) == 1;
    }
}
设哈希表的大小为 \textit{base}base，则可以设计一个简单的哈希函数：\text{hash}(x) = x \bmod \textit{base}hash(x)=xmodbase。

我们开辟一个大小为 \textit{base}base 的数组，数组的每个位置是一个链表。当计算出哈希值之后，就插入到对应位置的链表当中。

由于我们使用整数除法作为哈希函数，为了尽可能避免冲突，应当将取质数更好


class MyHashSet {
    private static final int BASE = 769;
    private LinkedList[] data;

    /** Initialize your data structure here. */
    public MyHashSet() {
        data = new LinkedList[BASE];
        for (int i = 0; i < BASE; ++i) {
            data[i] = new LinkedList<Integer>();
        }
    }
    
    public void add(int key) {
        int h = hash(key);
        Iterator<Integer> iterator = data[h].iterator();
        while (iterator.hasNext()) {
            Integer element = iterator.next();
            if (element == key) {
                return;
            }
        }
        data[h].offerLast(key);
    }
    
    public void remove(int key) {
        int h = hash(key);
        Iterator<Integer> iterator = data[h].iterator();
        while (iterator.hasNext()) {
            Integer element = iterator.next();
            if (element == key) {
                data[h].remove(element);
                return;
            }
        }
    }
    
    /** Returns true if this set contains the specified element */
    public boolean contains(int key) {
        int h = hash(key);
        Iterator<Integer> iterator = data[h].iterator();
        while (iterator.hasNext()) {
            Integer element = iterator.next();
            if (element == key) {
                return true;
            }
        }
        return false;
    }

    private static int hash(int key) {
        return key % BASE;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/design-hashset/solution/she-ji-ha-xi-ji-he-by-leetcode-solution-xp4t/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


