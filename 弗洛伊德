弗洛伊德和迪杰斯特拉最大的区别就是，迪杰斯特拉必须要按照 v0 ，v0-v1,v0-v1-v2这样的顺序不断加入节点来判断所需的距离，而弗洛伊德是必须经过加入的节点

 详细见这个博主给的图片和讲解
https://blog.csdn.net/qq_15028305/article/details/85774037
弗洛伊德的大概过程就是先将1加入节点，更新经过1可以通过的结点
紧接着加入2节点，注意到这里就是与迪杰斯特拉的区别了，这时用2当起点，找2为起点可以更新的距离，最后以1-2为顺序，找经过他们两个可以更新的距离，然后就重复操作到所有节点都加入
总的来说就是假如我们想知道i，j最短的路径到底是什么，我们就需要加入节点，通过i，k,j加节点来找有没有通过k来减少他们俩点的距离，当然这个k并不唯一
可以加入很多k来减少这个距离，比如我们从4号城市到3号城市（4->3）的路程e[4][3]原本是12。如果只通过1号城市中转（4->1->3），路程将缩短为11（e[4][1]+e[1][3]=5+6=11）
对应的代码应该是
for(int i=1;i<=n;i++)
{
for(int j=1;j<=n;j++)
{
  if(dp[i][j]>dp[i][1]+dp[1][j])
  {
     dp[i][j]=dp[i][1]+dp[1][j];
     }
     }
     }
 那么上面这个是更新对应1节点的时候
  if (dp[i][j] > dp[i][2]+dp[2][j])  dp[i][j]=dp[i][2]+dp[2][j];
 而这个就是对应加入2节点的时候、
 
 故整体代码就是
   for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
            if(i==j) dp[i][j]=0;  
              else dp[i][j]=inf;

 for(int k=1;k<=n;k++)
 {
 for(int i=1;i<=n;i++)
{
for(int j=1;j<=n;j++)
{
  if(dp[i][j]>dp[i][k]+dp[k][j])
  {
     dp[i][j]=dp[i][k]+dp[k][j];
     }
     }
     }
     }
     借用博主的一句话  ，这一篇是方便我自己复习用的，如果想详细了解，可以关注这个博主
     这段代码的基本思想就是：
     最开始只允许经过1号顶点进行中转，接下来只允许经过1和2号顶点进行中转……允许经过1~n号所有顶点进行中转，
     求任意两点之间的最短路程。用一句话概括就是：从i号顶点到j号顶点只经过前k号点的最短路程。


     }
